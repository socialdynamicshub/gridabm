---
title: "Grid Agent-Based Models"
description: |
  This article runs you through using the `gridabm` library to play around with 2D cellular automata or grid ABMs.
author:
  - name: Johannes Nakayama 
    url: https://github.com/JohannesNakayama
date: "`r Sys.Date()`"
bibliography: references.bib
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(gridabm)
library(ggplot2)
library(dplyr)
library(readr)
set.seed(420)
```

## Installation

You will need the `remotes` library to install `gridabm` from Github.

```{r, echo=TRUE, eval=FALSE}
# install.packages("remotes")
remotes::install_github("socialdynamicshub/gridabm")
```


## First Steps

The `gridabm` library lets you play around with cellular automata on 2D grids.
You can think of a grid just as a board of cells.

```{r, echo=FALSE}
matrix(rep(0, 400), nrow = 20) %>% 
  plot_state(5, c("white")) +
  labs(title = "A 20x20 grid")
```

In this library, the grid plotted above corresponds to a matrix with distinct numeric states.
Let's for example create a matrix with the distinct states $0$ and $1$.
Let's say state $0$ means that the cell is empty, so we assign it the color white.
State $1$ represents "something" on the board, we'll assign it the color black.

Then the following matrix...

$$
\begin{pmatrix}
0 & 0 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
1 & 0 & 0 & 0 & 1\\
0 & 1 & 1 & 0 & 0\\
1 & 0 & 0 & 0 & 0
\end{pmatrix}
$$

... corresponds to the following plot:

```{r}
mat <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 1),
      c(0, 1, 0, 0, 1),
      c(1, 0, 0, 0, 1),
      c(0, 1, 1, 0, 0),
      c(1, 0, 0, 0, 0)
    ),
    nrow = 5
  )
)
plot_state(mat, marker_size = 18, color_scheme = c("white", "black")) +
  scale_x_continuous(limits = c(0.5, 5.5)) +
  scale_y_continuous(limits = c(0.5, 5.5)) +
  NULL
```

You can construct boards with more distinct states in the same way.

Apart from a grid, a set of distinct states, and an initial state, in a cellular automaton, we need a so-called update rule.
In **Agent-Based Modeling**, this is sometimes referred to as a *stepping function*.

In the `gridabm` library, a stepping function is simply a function that takes a matrix with numeric states, performs the update rule, and returns the updated matrix.

Let's examine this with a very simple example.
We use a matrix with distinct states $0$ and $1$.
Now we define an update rule as follows:

> Each cell adopts the state of the cell to its right.

We could implement this rule like this:

```{r, echo=TRUE}
left_shift_rule <- function(m) {
  axis_size <- dim(m)[1]
  m_upd <- m
  
  for (i in 1:axis_size) {
    for (j in 1:axis_size) {
      if (j < axis_size) {
        new_j <- j + 1
      } else {
        new_j <- 1
      }
      m_upd[i, j] <- m[i, new_j] 
    }
  }
  
  return(m_upd)
}
```

Now, let's create an initial state, run the simulation, and animate it.
To change things up, let's assign the color white to state $0$ and blue to state $1$

```{r, echo=TRUE}
left_shift_board <- matrix(
  sample(c(0, 1), prob = c(0.7, 0.3), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
left_shift_results <- run_automaton(
  left_shift_board, steps = 100, stepfunc = left_shift_rule
)
animate_model_run(
  left_shift_results, marker_size = 5, color_scheme = c("white", "blue")
)
```

The code above is the general workflow of `gridabm`.

First, you create a state that you want to start from.
It's a simple `matrix` with several distinct states.

```{r, echo=TRUE, eval=FALSE}
left_shift_board <- matrix(
  sample(c(0, 1), prob = c(0.7, 0.3), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
```

Then, you run the automaton with the step function (`stepfunc`) that you defined before.

```{r, echo=TRUE, eval=FALSE}
left_shift_results <- run_automaton(
  left_shift_board, steps = 100, stepfunc = left_shift_rule
)
```

The results can be animated with the convenience function `animate_model_run`.

```{r, echo=TRUE, eval=FALSE}
animate_model_run(
  left_shift_results, marker_size = 5, color_scheme = c("white", "blue")
)
```




## Simulating a Forest Fire

Several well-known cellular automata (or agent-based model, depending on how you view it) are implemented in this package.
One of them is the so-called forest fire simulation [@drossel1992selforganized].

Let's first create a board.
For the forest fire, there is a convenience function because there is a specific way this model is usually setup.

```{r, echo=TRUE}
forest <- create_forest(axis_size = 20, tree_density = 0.7)
plot_state(
  forest,
  marker_size = 5,
  color_scheme = c("white", "green", "orange", "firebrick")
)
```

The color coding is intended to mimic an actual forest fire:
Green cells are trees, orange cells are trees on fire, dark red (`firebrick`) cells are burnt trees, and white cells are empty.
You can see in the plot that the trees on the left of the board are all on fire and the rest of the trees are scattered across the board.

In the `create_forest` convenience function, we set up a parameter `tree_density`.
This is just the probability with which a tree is put on each cell.
An example of a sparser forest would look like this:

```{r}
create_forest(axis_size = 20, tree_density = 0.3) %>% 
  plot_state(
    marker_size = 5, color_scheme = c("white", "green", "orange", "firebrick")
  )
```

... and a more dense one would look like this:

```{r}
create_forest(axis_size = 20, tree_density = 0.9) %>% 
  plot_state(
    marker_size = 5, color_scheme = c("white", "green", "orange", "firebrick")
  )
```

The stepping function for the forest fire is called `forest_fire_step`.
You can run and animate the automaton like this:

```{r, echo=FALSE}
if (!file.exists("forest_1_results.RDS")) {
  forest <- create_forest(20, 0.7)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_1_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_1_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.7)
forest_results <- run_automaton(forest, 100, forest_fire_step)
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

```{r, echo=FALSE}
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

As you can see, a wall of fire runs through the forest pretty quickly.

Let's see, how this looks like in a less dense forest.

```{r, echo=FALSE}
if (!file.exists("forest_2_results.RDS")) {
  forest <- create_forest(20, 0.3)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_2_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_2_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.3)
forest_results <- run_automaton(forest, 100, forest_fire_step)
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

```{r, echo=FALSE}
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

The fire doesn't run through the entire forest, but stops almost immediately.

Let's look how tree density is related to the percentage of the forest burnt after the fire has run its course.

```{r, fig.width=8, fig.height=12}
d <- data.frame()
for (density in seq(0.1, 0.9, 0.1)) {
  forest <- create_forest(20, density)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  forest_results$density <- density
  d <- dplyr::bind_rows(d, forest_results)
}

d %>% 
  filter(step <= 40) %>% 
  filter((state == 1) | (state == 3)) %>% 
  group_by(density, step, state) %>% 
  summarize(count = n()) %>% 
  ungroup() %>% 
  group_by(density, step) %>% 
  mutate(forest_size = sum(count)) %>% 
  ungroup() %>% 
  mutate(relfreq = count / forest_size) %>% 
  mutate(burnt = state == 3) %>% 
  ggplot(aes(x = step, y = relfreq, color = burnt)) +
  geom_line() +
  geom_point(shape = 21, fill = "white") +
  scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 1)) + 
  scale_color_manual(values = c("green", "firebrick")) +
  facet_wrap(. ~ density, ncol = 1) +
  labs(
    color = "Burnt",
    x = "Step",
    y = "Relative Frequency"
  ) +
  theme(
    panel.background = element_rect(fill = "white", color = "lightgrey"),
    strip.background = element_rect(fill = "white", color = "transparent"),
    panel.grid.major.x = element_line(color = "lightgrey"),
    panel.grid.major.y = element_line(color = "lightgrey"),
    axis.ticks = element_line(color = "lightgrey")
  )
```




## Some Other Rules

[Descriptions coming soon]


```{r, echo=TRUE}
forest <- matrix(
  sample(c(0, 1, 2), prob = c(0.3, 0.68, 0.02), replace = TRUE, size = 10000),
  nrow = 100, ncol = 100
)
forest_results <- run_automaton(forest, 200, forest_fire_step)
animate_model_run(forest_results, 1, c("white", "green", "orange", "firebrick")) +
  theme(
    panel.grid.major = element_line(color = "white"),
    panel.grid.minor = element_line(color = "white")
  )
```



```{r, echo=TRUE}
life_board <- matrix(
  sample(c(0, 1), prob = c(0.8, 0.2), replace = TRUE, size = 625),
  nrow = 25, ncol = 25
)
life_results <- run_automaton(life_board, 100, life_step)
animate_model_run(life_results, 4, c("white", "black"))
```



```{r, echo=TRUE}
schelling_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.1, 0.45, 0.45), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
schelling_results <- run_automaton(schelling_board, 100, schelling_step, tolerance = 3)
animate_model_run(schelling_results, 5, c("white", "orange", "blue"))
```



```{r, echo=TRUE}
brians_brain_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.5, 0.25, 0.25), replace = TRUE, size = 2500),
  nrow = 50, ncol = 50
)
brians_brain_results <- run_automaton(brians_brain_board, 200, brians_brain_step)
animate_model_run(brians_brain_results, 2, c("black", "white", "blue")) +
  theme(
    panel.background = element_rect(fill = "black"),
    panel.grid.major = element_line(color = "black"),
    panel.grid.minor = element_line(color = "black")
  )
```



