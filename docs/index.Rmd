---
title: "`gridabm`: A Tool for 2D Cellular Automata and Agent-Based Models"
description: |
  The `gridabm` library provides tools for building, visualizing, and analyzing cellular automata and agent-based models that run on a 2D grid. This article describes the general workflow of the package and shows you how to build your own automata or analyze the ones implemented in this package.
author:
  - name: Johannes Nakayama 
    url: https://github.com/JohannesNakayama
date: "`r Sys.Date()`"
bibliography: references.bib
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(gridabm)
library(ggplot2)
library(dplyr)
library(readr)
set.seed(420)
```

## Installation

To install the `gridabm` library, you need the `remotes` package to install it from Github.
If you haven't installed `remotes` yet, you can get it from CRAN:

```{r}
install.packages("remotes")
```

Then, install `gridabm` from Github:

```{r, echo=TRUE, eval=FALSE}
remotes::install_github("socialdynamicshub/gridabm")
```


## First Steps

The `gridabm` library lets you play around with cellular automata on 2D grids.
You can think of a grid just as a board of cells.

```{r, echo=FALSE}
matrix(rep(0, 400), nrow = 20) %>% 
  plot_state(5, c("white")) +
  labs(title = "A 20x20 grid")
```

In the `gridabm` library, the grid is represented by a *matrix* whose entries only take on values from a set of distinct numeric states.
Let's for example create a matrix with the distinct states $0$ and $1$.
Let's say state $0$ means that the cell is empty, so we assign it the color white.
State $1$ represents "something" on the board, we'll assign it the color black.

Then the following matrix...

$$
\begin{pmatrix}
0 & 0 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
1 & 0 & 0 & 0 & 1\\
0 & 1 & 1 & 0 & 0\\
1 & 0 & 0 & 0 & 0
\end{pmatrix}
$$

... corresponds to the following plot:

```{r}
mat <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 1),
      c(0, 1, 0, 0, 1),
      c(1, 0, 0, 0, 1),
      c(0, 1, 1, 0, 0),
      c(1, 0, 0, 0, 0)
    ),
    nrow = 5
  )
)
plot_state(mat, marker_size = 18, color_scheme = c("white", "black")) +
  scale_x_continuous(limits = c(0.5, 5.5)) +
  scale_y_continuous(limits = c(0.5, 5.5)) +
  NULL
```

You can construct boards with more distinct states in the same way.



### Update Rules

Apart from a grid, a set of distinct states, and an initial state, we need a so-called **update rule**.
In *agent-based modeling*, this is sometimes referred to as a **stepping function**.
Usually, the update rules are defined at the cell/agent level, meaning that the state of an agent in the next iteration of the automaton is contingent on the states of its neighbors (or a subset of them).

What constitutes the neighborhood of an agent can be defined in different ways, but common neighborhoods are implemented in the package.
For instance, the Moore neighborhood is simply the set of all adjacent cells, including diagonally adjacent ones.

```{r}
mat <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 2, 2, 2, 0, 0),
      c(0, 0, 2, 1, 2, 0, 0),
      c(0, 0, 2, 2, 2, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0)
    ),
    nrow = 7
  )
)
plot_state(mat, marker_size = 18, color_scheme = c("white", "grey20", "grey80"))
```

In this example, the Moore neighborhood of the darker cell is given by the lighter cells.
To get the coordinates of a cell's Moore neighborhood in the `gridabm` package, use the `get_moore_neighborhood` function.

```{r, echo=TRUE, eval=FALSE}
get_moore_neighborhood(i = 4, j = 5, axis_size = 20, periodic = TRUE)
```

`i` and `j` are the coordinates in the matrix, `axis_size` refers to the dimension of the matrix in either direction^[currently, only square grids are possible], and the `periodic` parameter indicates whether the grid wraps around (i.e., more precisely, we're dealing with a torus).

In the `gridabm` library, update rules are simply functions that

* take a matrix with numeric states,
* perform the update rule for each cell,
* and return the updated matrix.

The updated matrix should only contain values in the set of distinct states that we defined in the beginning.

Let's examine this with a very simple example.
We use a matrix with distinct states $0$ and $1$.
Now we define an update rule as follows:

> Each cell adopts the state of the cell to its right.

We could implement this rule like this:

```{r, echo=TRUE}
left_shift_rule <- function(m) {
  axis_size <- dim(m)[1]
  m_upd <- m
  
  for (i in 1:axis_size) {
    for (j in 1:axis_size) {
      if (j < axis_size) {
        new_j <- j + 1
      } else {
        new_j <- 1
      }
      m_upd[i, j] <- m[i, new_j] 
    }
  }
  
  return(m_upd)
}
```

Now, let's create an initial state, run the simulation, and animate it.
To change things up, let's assign the color white to state $0$ and blue to state $1$

```{r, echo=TRUE}
left_shift_board <- matrix(
  sample(c(0, 1), prob = c(0.7, 0.3), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
left_shift_results <- run_automaton(
  left_shift_board, steps = 100, stepfunc = left_shift_rule
)
animate_model_run(
  left_shift_results, marker_size = 5, color_scheme = c("white", "blue")
)
```

The code above is the general workflow of `gridabm`.

First, you create a state that you want to start from.
It's a simple `matrix` with several distinct states.

```{r, echo=TRUE, eval=FALSE}
left_shift_board <- matrix(
  sample(c(0, 1), prob = c(0.7, 0.3), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
```

Then, you run the automaton with the step function (`stepfunc`) that you defined before.

```{r, echo=TRUE, eval=FALSE}
left_shift_results <- run_automaton(
  left_shift_board, steps = 100, stepfunc = left_shift_rule
)
```

The results can be animated with the convenience function `animate_model_run`.

```{r, echo=TRUE, eval=FALSE}
animate_model_run(
  left_shift_results, marker_size = 5, color_scheme = c("white", "blue")
)
```






## Simulating a Forest Fire

Several well-known cellular automata (or agent-based models, depending on how you view it) are implemented in this package.
One of them is the so-called forest fire simulation [@drossel1992selforganized].

Let's first create a board.
For the forest fire, there is a convenience function because there is a specific way this model is usually setup.

```{r, echo=TRUE}
forest <- create_forest(axis_size = 20, tree_density = 0.7)
plot_state(
  forest,
  marker_size = 5,
  color_scheme = c("white", "green", "orange", "firebrick")
)
```

The color coding is intended to mimic an actual forest fire:
Green cells are trees, orange cells are trees on fire, dark red (`firebrick`) cells are burnt trees, and white cells are empty.
You can see in the plot that the trees on the left of the board are all on fire and the rest of the trees are scattered across the board.

In the `create_forest` convenience function, we set a parameter `tree_density`.
This is just the probability with which a tree is put on each cell.
An example of a sparser forest would look like this:

```{r, echo=TRUE}
create_forest(axis_size = 20, tree_density = 0.3) %>% 
  plot_state(
    marker_size = 5, color_scheme = c("white", "green", "orange", "firebrick")
  )
```

... and a more dense one would look like this:

```{r, echo=TRUE}
create_forest(axis_size = 20, tree_density = 0.9) %>% 
  plot_state(
    marker_size = 5, color_scheme = c("white", "green", "orange", "firebrick")
  )
```

The stepping function for the forest fire is called `forest_fire_step`.
You can run and animate the automaton like this:

```{r, echo=FALSE}
if (!file.exists("forest_1_results.RDS")) {
  forest <- create_forest(20, 0.7)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_1_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_1_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.7)
forest_results <- run_automaton(forest, 100, forest_fire_step)
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

```{r, echo=FALSE}
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

As you can see, a wall of fire runs through the forest pretty quickly.

Let's see, how this looks like in a less dense forest.

```{r, echo=FALSE}
if (!file.exists("forest_2_results.RDS")) {
  forest <- create_forest(20, 0.3)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_2_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_2_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.3)
forest_results <- run_automaton(forest, 100, forest_fire_step)
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

```{r, echo=FALSE}
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

The fire doesn't run through the entire forest, but stops almost immediately.

Now these animations are nice, but we can go beyond merely looking at the model and analyze the effects of different parameters in-depth.
The `run_automaton` function returns a `data.frame` that contains the results of the model run.

```{r, echo=FALSE}
if (!file.exists("forest_3_results.RDS")) {
  forest <- create_forest(20, 0.7)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_3_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_3_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.7)
forest_results <- run_automaton(forest, 100, forest_fire_step)
head(forest_results, 20)
```

```{r, echo=FALSE}
head(forest_results, 20) %>% knitr::kable()
```


Let's look how tree density is related to how quickly the fire runs through the forest and how much of the forest is burnt.

```{r, fig.width=8, fig.height=12}
d <- data.frame()
for (density in seq(0.1, 0.9, 0.1)) {
  forest <- create_forest(20, density)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  forest_results$density <- density
  d <- dplyr::bind_rows(d, forest_results)
}

d %>% 
  filter(step <= 40) %>% 
  filter((state == 1) | (state == 3)) %>% 
  group_by(density, step, state) %>% 
  summarize(count = n()) %>% 
  ungroup() %>% 
  group_by(density, step) %>% 
  mutate(forest_size = sum(count)) %>% 
  ungroup() %>% 
  mutate(relfreq = count / forest_size) %>% 
  mutate(burnt = state == 3) %>% 
  ggplot(aes(x = step, y = relfreq, color = burnt)) +
  geom_line() +
  geom_point(shape = 21, fill = "white") +
  scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 1)) + 
  scale_color_manual(values = c("green", "firebrick")) +
  facet_wrap(. ~ density, ncol = 1) +
  labs(
    color = "Burnt",
    x = "Step",
    y = "Relative Frequency"
  ) +
  theme(
    panel.background = element_rect(fill = "white", color = "lightgrey"),
    strip.background = element_rect(fill = "white", color = "transparent"),
    panel.grid.major.x = element_line(color = "lightgrey"),
    panel.grid.major.y = element_line(color = "lightgrey"),
    axis.ticks = element_line(color = "lightgrey")
  )
```




## Some Other Rules

[Descriptions coming soon]


```{r, echo=TRUE, eval=FALSE}
forest <- matrix(
  sample(c(0, 1, 2), prob = c(0.3, 0.68, 0.02), replace = TRUE, size = 10000),
  nrow = 100, ncol = 100
)
forest_results <- run_automaton(forest, 200, forest_fire_step)
animate_model_run(forest_results, 1, c("white", "green", "orange", "firebrick")) +
  theme(
    panel.grid.major = element_line(color = "white"),
    panel.grid.minor = element_line(color = "white")
  )
```



```{r, echo=TRUE, eval=FALSE}
life_board <- matrix(
  sample(c(0, 1), prob = c(0.8, 0.2), replace = TRUE, size = 625),
  nrow = 25, ncol = 25
)
life_results <- run_automaton(life_board, 100, life_step)
animate_model_run(life_results, 4, c("white", "black"))
```



```{r, echo=TRUE, eval=FALSE}
schelling_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.1, 0.45, 0.45), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
schelling_results <- run_automaton(schelling_board, 100, schelling_step, tolerance = 3)
animate_model_run(schelling_results, 5, c("white", "orange", "blue"))
```



```{r, echo=TRUE, eval=FALSE}
brians_brain_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.5, 0.25, 0.25), replace = TRUE, size = 2500),
  nrow = 50, ncol = 50
)
brians_brain_results <- run_automaton(brians_brain_board, 200, brians_brain_step)
animate_model_run(brians_brain_results, 2, c("black", "white", "blue")) +
  theme(
    panel.background = element_rect(fill = "black"),
    panel.grid.major = element_line(color = "black"),
    panel.grid.minor = element_line(color = "black")
  )
```



