---
title: "Grid Agent-Based Models"
description: |
  This article runs you through using the `gridabm` library to play around with 2D cellular automata or grid ABMs.
author:
  - name: Johannes Nakayama 
    url: https://github.com/JohannesNakayama
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(gridabm)
library(ggplot2)
library(readr)
set.seed(420)
```

## Installation

You will need the `remotes` library to install `gridabm` from Github.

```{r, echo=TRUE, eval=FALSE}
# install.packages("remotes")
remotes::install_github("socialdynamicshub/gridabm")
```


## First Steps

The `gridabm` library lets you play around with cellular automata on 2D grids.
You can think of a grid just as a board of cells.

```{r, echo=FALSE}
matrix(rep(0, 400), nrow = 20) %>% 
  plot_state(5, c("white")) +
  labs(title = "A 20x20 grid")
```

In this library, the grid plotted above corresponds to a matrix with distinct numeric states.
Let's for example create a matrix with the distinct states $0$ and $1$.
Let's say state $0$ means that the cell is empty, so we assign it the color white.
State $1$ represents "something" on the board, we'll assign it the color black.

Then the following matrix...

$$
\begin{pmatrix}
0 & 0 & 0 & 0 & 1\\
0 & 1 & 0 & 0 & 1\\
1 & 0 & 0 & 0 & 1\\
0 & 1 & 1 & 0 & 0\\
1 & 0 & 0 & 0 & 0
\end{pmatrix}
$$

... corresponds to the following plot:

```{r}
mat <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 1),
      c(0, 1, 0, 0, 1),
      c(1, 0, 0, 0, 1),
      c(0, 1, 1, 0, 0),
      c(1, 0, 0, 0, 0)
    ),
    nrow = 5
  )
)
plot_state(mat, marker_size = 18, color_scheme = c("white", "black")) +
  scale_x_continuous(limits = c(0.5, 5.5)) +
  scale_y_continuous(limits = c(0.5, 5.5)) +
  NULL
```

You can construct boards with more distinct states in the same way.

Apart from a grid, a set of distinct states, and an initial state, in a cellular automaton, we need a so-called update rule.
In **Agent-Based Modeling**, this is sometimes referred to as a *stepping function*.

In the `gridabm` library, a stepping function is simply a function that takes a matrix with numeric states, performs the update rule, and returns the updated matrix.

Let's examine this with a very simple example.
We use a matrix with distinct states $0$ and $1$.
Now we define an update rule as follows:

> Each cell adopts the state of the cell to its right.

We could implement this rule like this:

```{r, echo=TRUE}
left_shift_rule <- function(m) {
  axis_size <- dim(m)[1]
  m_upd <- m
  
  for (i in 1:axis_size) {
    for (j in 1:axis_size) {
      if (j < axis_size) {
        new_j <- j + 1
      } else {
        new_j <- 1
      }
      m_upd[i, j] <- m[i, new_j] 
    }
  }
  
  return(m_upd)
}
```

Now, let's create an initial state.
To change things up, let's assign the color white to state $0$ and blue to state $1$

```{r}
left_shift_board <- matrix(
  sample(c(0, 1), prob = c(0.7, 0.3), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
plot_state(left_shift_board, marker_size = 5, color_scheme = c("white", "blue"))
```

Running and animating this automaton works like this:

```{r, echo=TRUE}
left_shift_results <- run_automaton(
  left_shift_board, steps = 100, stepfunc = left_shift_rule
)
animate_model_run(left_shift_results, marker_size = 5, color_scheme = c("white", "blue"))
```

The naming of the rule might have given it away already, but this rule just "shifts" everything to the left.
This configuration might make this more clear:

```{r}
mat <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 1, 0, 1, 0, 1, 0, 1),
      c(0, 0, 0, 1, 0, 1, 0, 0, 0, 1),
      c(0, 0, 0, 1, 1, 1, 0, 1, 0, 1),
      c(0, 0, 0, 1, 0, 1, 0, 1, 0, 0),
      c(0, 0, 0, 1, 0, 1, 0, 1, 0, 1),
      c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    ),
    nrow = 10
  )
)
left_shift_results <- run_automaton(mat, 100, left_shift_rule)
animate_model_run(left_shift_results, 9, c("white", "blue"))
```




## Simulating a Forest Fire


```{r, echo=FALSE}
if (!file.exists("forest_results.RDS")) {
  forest <- create_forest(20, 0.7)
  forest_results <- run_automaton(forest, 100, forest_fire_step)
  readr::write_rds(forest_results, "forest_results.RDS")  
} else {
  forest_results <- readr::read_rds("forest_results.RDS")
}
```

```{r, echo=TRUE, eval=FALSE}
forest <- create_forest(20, 0.7)
forest_results <- run_automaton(forest, 100, forest_fire_step)
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```

```{r, echo=FALSE}
animate_model_run(forest_results, 5, c("white", "green", "orange", "firebrick"))
```








```{r, echo=TRUE}
forest <- matrix(
  sample(c(0, 1, 2), prob = c(0.3, 0.68, 0.02), replace = TRUE, size = 10000),
  nrow = 100, ncol = 100
)
forest_results <- run_automaton(forest, 200, forest_fire_step)
animate_model_run(forest_results, 1, c("white", "green", "orange", "firebrick")) +
  theme(
    panel.grid.major = element_line(color = "white"),
    panel.grid.minor = element_line(color = "white")
  )
```



```{r, echo=TRUE}
life_board <- matrix(
  sample(c(0, 1), prob = c(0.8, 0.2), replace = TRUE, size = 625),
  nrow = 25, ncol = 25
)
life_results <- run_automaton(life_board, 100, life_step)
animate_model_run(life_results, 4, c("white", "black"))
```



```{r, echo=TRUE}
schelling_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.1, 0.45, 0.45), replace = TRUE, size = 400),
  nrow = 20, ncol = 20
)
schelling_results <- run_automaton(schelling_board, 100, schelling_step, tolerance = 3)
animate_model_run(schelling_results, 5, c("white", "orange", "blue"))
```



```{r, echo=TRUE}
brians_brain_board <- matrix(
  sample(c(0, 1, 2), prob = c(0.5, 0.25, 0.25), replace = TRUE, size = 2500),
  nrow = 50, ncol = 50
)
brians_brain_results <- run_automaton(brians_brain_board, 100, brians_brain_step)
animate_model_run(brians_brain_results, 2, c("black", "white", "blue")) +
  theme(
    plot.background = element_rect(fill = "black"),
    panel.background = element_rect(fill = "black"),
    panel.grid.major = element_line(color = "black"),
    panel.grid.minor = element_line(color = "black")
  )
```



